---
layout: post
title:  "DDD START"
date:   2023-06-28 23:20:21 +0900
categories: dd, Architecture
---

> DDD Start ! 최범균님 책 읽기

궁극적인목표 
- PO와 개발자가 대화할 때 통역이 필요없다.
    - 즉 용어가 통일되어있고 서로 얘기하는것이 코드에 그대로 반영이 된다.
유비쿼터스 언어
- 도메인전문가와 개발자가 얘기했을 때 공통적인 언어 (모든 사람이 같은의미로 말할 수 있도록 정리된 사전) -> 설명이 필요없다.
컨텍스트
- 유비쿼터스 언어가 정확한 의미를 가지는 범위

Entity
- 가장 중요한 것은 식별자이다.
- 도메인 모델의 데이터를 포함하여 해당 데이터와 관련된 기능을 함께 제공
Value
- 고유의 식별자를 갖지 않는 객체
- 하나의 도메인 객체의 속성을 표현할 때 사용
- 배송지 주소를 표현하기 위한 주소나 구매 금액을 표현하기 위한 금액(Money)와 같은 타입의 밸류이다.
Aggregate
- 엔티티와 벨류 객체를 개념적으로 하나 묶은 것 -> 관련된 객체를 하나로 묶는 것
- Order, OrderLine, Orderer 밸류 객체를 주문 이라는 애그리거트로 묶을 수 있다.
- 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 같은 어그리게이트에서 다른 어그리게이트의 상태를 변경하는 것은 어그리게이트간의 의존도를 높여 결과적으로 변경을 어렵게 만든다.

앤티티와 밸류 기본 매핑 구현
- 애그리거트 루트는 엔티티이므로 @Entity 매핑 설정한다.
- 한 테이블에 엔티티와 벨류 데이터가 같이있다면,
    - 벨류는 @Embeddable로 매핑 설정한다.
    - 벨류 타입 프로퍼티는 @Embedded로 매핑설정한다.

에그리거트의 영속성 전파
> 에그리거트가 완전한 상태여야 한다는 것은 에거리거트 루트를 조회할 때 뿐만아니라 저장하고 삭제할 때도 하나로 처리되어야한다.

@Embeddable 매핑 타입의 경우 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다. 

식별자 생성 기능
1. 사용자가 직접 생성
2. 도메인 로직으로 생성
3. DB를 이용한 일려번호 사용


파사드 패턴?
> 저수준 인터페이스들을 고수준 인터페이스로 묶어주는 패턴 
저 수준 인터페이스를 바꾸기 위해서 다른 인터페이슨느 건드리지 않고 통합 인터페이스의 코드만 건드리면 되므로 클라이언트 객체는 여러 저수준 인터페이스에 대해 의존성이 느슨해진다.

`도메인 서비스`
여러 에그리거트가 필요할 경우에 자신의 책임범위를 넘어서는 기능을 구현하기에 외부에 대한 의존도가 높아진다. 해결방법은 도메인서비스
- 어그리거트 객체에 도메인 서비스를 전달한다.
    - 예시) 할인 계산 서비스 (order, orderline, coupon)

```java
public class DiscountCalculatorService {
    public Money discountAmounts(List<OrderLine> orderlines, List<Coupon> coupons, MemberGrade grade) {
        ...
    }
}

public class Order {
    public void calculateAmounts(DiscountCalculatorService service) {
        ...
    }
}

혹은

public class OrderService {
    private DiscountCalculatorService discountCalculatorService;
    ...
}

```

선점 잠금과 교착 상태
선점잠금 : 2개의 스레드 중 하나의 스레드가 먼저 락을 획득 후 로직이 끝난 후 다른 프로세스가 접근 가능

1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도

-> 선점잠근은 사용자가 수가 많을 수록 발생할 가능성이 높다. 교착상태에 빠질수록 스레드수가 증가하여 서버가 죽을 수 있다. 이런 문제를 해결하기 위해 잠금을 구할 때 최대 대기시간을 지정해야한다.

비섬점 잠금: 잠금을 동시에 하여 동시에 접근을 막는것 변경한 데이터를 실제 dbms에 반영하는 시점에 변경 가능 여부를 확인하는 방식

1. 운영자는 배송을 위해 주문 정보 조회, 시스템은 정보를 제공
2. 고객이 배송지 변경을 위해 변경 폼 요청, 시스템은 변경 폼 제공
3. 고객이 새로운 배송지를 입력하고 폼을 전송해 배송지를 변경
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경

### 도메인 모델과 Bounded Context
- Bounded Context
    - 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 용어를 기준으로 컨텍스트를 분리할 수 있다. 실제로 사용자에게 제공하는 물리적인 시스템으로 도메인 모델은 Bounded Context안에서 도메인을 구현한다.
    - Bounded Context에서 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하위 도메인을 위한 모델이 서로 뒤섞이지 않아서 하위 도메인마다 Bounded Context를 갖는 효과를 낼 수 있다.
- 모든 Bounded Context를 반드시 도메인 주도로 개발할 필요 없다.
    - 상품의 리뷰는 복잡하지 않은 로직이기때문에 CRUD로 개발해도 된다. 즉, DAO와 데이터 중심의 밸류 객체를 이용해서 개발해도된다.
    - Bounded Context에서 두 방식을 혼합할 수 있다.
    - CQRS(Command Query Responsebility Segregation): 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모데을 구분하는 패턴
- Bounded Context 간 통합
    - 기존 서비스 중 새로운 서비스가 추가되어야할 때가 있을 때 통합이 이루어져야한다.
    - 예) 상품 및 상품 추천시스템(새로운 서비스)
    - 추천 시스템은 사용자의 조회 상품이력이나 구매이력 상품과 같은 사용자 활동 이력을 필요로 하는데 이 내역을 전달할 때 메시지 큐를 사용할 수 있다.
    - 카탈로그 -> (이력을 메시지 형식으로 큐에 추가) > 메시지 시스템 <(메시지 큐에서 가져옴) 
- Bounded Context 간에 가장 흔한 관계는 한쪽에서 다른 한쪽으로 API 호출하는 관계인대, 양방향 일 때?
    - `공유커널`: 두 Bounded Context가 같은 모델을 공유하는 경우 같은 것을 표현하는 모델을 공유함으로써 중복 개발을 막을 수 있다. 
- Context Map
    - Bounded Context에 매몰되면 전체를 보지 못할 때가 있다.
    - 전채 비즈니스를 조망할 수 있는 지도가 필요한데 그것이 컨텍스트 맵이다.
    - 간단한 도형과 선을 이용하여 각 컨텍스트의 관계를 이해할 수 있는 수준으로 그리면 된다.

### 이벤트
- 시스템 간 강결합 문제
    - 외부서비스와의 문제에서 외부 서비스가 문제가 생겼을 때 트랜잭션 처리를 어떻게 해야할지 애매하다.
    - 환불 기능을 실행하는 과정에서 예외가 발생하면 트랜잭션을 롤백해야할지 커밋해야할지?
    - 성능
        - 외부 서비스에 응답 시간이 오래걸리면 그만큼 서비스도 지연된다.
    - 로직이 섞인다.
- 강결합 해결 => `이벤트`
    - 트리거: 도메인의 상태가 변경될 때 다른 후처리를 해야할 경우 
        - ex) 예매 결과를 SMS로 통지할 때도 이벤트 트리거를 사용한다. 예매도메인은 예매 완료를 이벤트시키고, 이벤트핸들러에서 SMS를 발송시키는 방식으로 구현
    - 서로 다른 시스템 간의 동기화
        - 배송지 변경을하면 외부 배송 서비스에 바뀐 배송지를 전송해야한다. 주문 도메인은 배송지 변경 이벤트를 발생시키고, 이벤트핸들러는 외부 배송서비스와 배송지정보를 동기화한다.
- 이벤트 클래스
    - 최소한의 데이터만 포함
- eventHandler: 이벤트 핸들러를 위한 상위 타입으로 모든 핸들러는 이 인터페이스를 구현
- 이벤트 디스팻처, 발행, 핸들러 등록등..
- 이벤트 처리 흐름
    1. 이벤트 처리에 필요한 이벤트 핸들러를 생성
    2. 이벤트 발생 전에 핸들러를 Events.handle() 메서드에 등록
    3. 이벤트를 발생시키는 도메인 기능 실행
    4. 도메인은 Events.raise() 사용하여 이벤트 발생
    5. 처리할 수 있는 이벤트인지 확인
    6. 처리 후 도메인 기능 실행 리턴
    9. evnets.reset() 
- 동기이벤트 처리문제
    - 외모 서비스로부터 응답이 느리다면?
    - 비동기 이벤트 치러
        - `A하면 이어서 B하라` => `A하면 일정시간 안에 B하라`
    - 로컬핸들러 비동기 실행
        - 별도의 스레드로 이벤트 핸들러를 실행하는 기능을 추가한다. (ExecutorService)

        ```java
        @Transactional
        public void cancel(OrderNo orderNo) {
            Events.handleAsync(
                (OrderCanceledEvent evt) -> refundService.refund(evt.getOrderNumber())
            );

            Order order = findOrder(orderNo);
            order.cancel();
        }
        ```

        - Events.handleAsync로 등록한 핸들러는 별도의 스레드에서 실행되므로 트랜잭션 범위에 묶이지 않는다.
        - `스프링 트랜잭션관리자는 보통 스레드를 이용하여 트랜잭션을 전파한다.`
    - 메시징 시스템을 이용한 비동기 구현
        - 메시징 큐를 사용
        - 메시지 큐는 이벤트 리스너에게 전달하고, 리스너는 알맞은 핸드러를 이용하여 처리한다. 이때 메시지 큐에 저장하는 과정과 메시지큐 에서 이벤트를 읽어 처리하는 과정은 별도의 프로세스 혹은 스레드를 이용한다.
    - 이벤트 저장소를 이용한 비동기 처리
        - 일단 디비에 저장 한 뒤 별도의 프로그램을 이용해서 이벤트 핸들러에 전달하는 것

## CQRS
- 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모데을 분리하는 패턴
- 도메인이 복잡할수록 명령기능과 조회기능이 다루는 데이터 범위에 차이가 발생하는데, 이 두 기능을 단일 모델로 처리하게 되면 필요 이상으로 복잡해지는 문제가 발생한다.
- CQRS를 사용하면 각 모델에 맞는 구현기술을 선택할 수 있다.
    - 객체 지향에 기반하여 도메인 구델을 구현하기에 적당한 JPA를 구현하고 조회모델은 MyBatis를 사용해서 구현할 수 있다.

<hr>

### [유투브 DDD 카카오 레퍼런스]https://www.youtube.com/watch?v=4QHvTeeTsj0
DDD란 ?
- 도메인의 모델과 로직에 집중
- 유비쿼터스 언어, 보편적 언어 사용
- 소프트웨어 entity와 도메인 간 개념의 일치

DDD 적용에 필요한 것?
- bounded context
    - 도메인간의 경계를 줘 의존성을 낮춘다.
- context map
- aggregate
    - 라이프사이클이 비슷한 것을 모아놓은 집합
- 장점
    - 보편적이 언어에 따른 빠른 커뮤니케이션
    - 도메인간 관계가 복잡한 경우 큰 틀에서 정리가 가능
    - 도메인의 분리에 따른 유지보수에 대한 편의성
    - 새로운 기능 및 요구 사항에 대한 유연성
    - 캡슐화 
    - 낮은 결합도, 높은 응집도
    - 비지니스 로직의 집중 => 도메인 로직의 분리
    - 코드 가독성
- 단점
    - 아키텍쳐 구현에서 생각되는 많은코드
    - 각 도메인에 대한 높은 이해도가 필요 


<hr>

### [유투브 DDD NHN 컨퍼런스](https://www.youtube.com/watch?v=6w7SQ_1aJ0A)
전술적 설계를 지양하자.
DDD(도메인 주도 설계)는 전략적 설계가 중요하다.
    - 해결해야하는 것이 뭐가 중요한지 알아내고 리소스를 투자하는 것이 시작이다.
`브라운 필드 전략적 설계`
도메인 전문가와 의사소통을 통하여 DDD가 진행이되어야한다.
큰 도메인 -> 작은 도메인으로 쪼갠다. => 조직의 역량을 집중해서 성공시켜아하는 목적이 있다. 문제공간 확보
    - 핵심 도메인
    - 지원 도메인
    - 일반 도메인
과정: 문제공간(도메인 전문가) -> 해결공간(개발자)
Bounded-context
콘웨이의 법칙: 소프트웨어의 구조는 해당 소프트웨어를 개발하는 조직의 구조를 따라간다.
