---
layout: post
title:  "RealMySQL - 4"
date:   2023-006-01 23:20:21 +0900
categories: db, mysql
---

> RealMySQL

# 실행계획
> MySQL에서는 Explain이라는 명령으로 쿼리의 실행계획을 확인할 수 있는데, 여기에는 많은 정보가 출력된다. DBMS에서는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다 => 옵티마이저

## MySQL의 주요 처리방식

### 풀 테이블 스캔
- 인덱스를 사용하지 않고, 테이블의 데이터를 첨부터 끝까지 읽어 요청된 작업을 처리
- 조건
    1. 테이블의 레코드 건수가 너무 작아 인덱스를 통해 읽는것보다 풀스캔이 더 빠른경우(테이블 페이지 1개로 구성된경우)
    2. WHERE 절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는경우
    3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드건수가 너무 많은 경우 반대로 max_seeks_for_key 변수를 특정 값으로 설정하면 MySQL 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고, 최대 N건만 읽으면 된다고 판단하게 된다. 
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드로 실행되다가 백그라운드로 전환되고, 그 시점에 한번에 4개 또는 8개 페이지를 읽으면서 그 수를 증가시킨다. 한번에 64개 페이지 데이터까지 읽어서 버퍼 풀에 저장해둔다. => 쿼리가 빠르게 처리된다.

### ORDER BY 처리(Using filesort)
- 레코드 1~2건을 가져오는 쿼리를 제외하면 대부분 SELECT 쿼리에서 정렬은 필수적으로 사용된다. 정렬을 처리하기 위해서는 인덱스를 이용하는 방법과 filesort라는 별도의 처리를 이용하는 방법이 있다.
- 인덱스 이용
    - 장점
        - insert, delete, update 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어 순서대로 읽기만 하면 된다.
    - 단점
        - insert, delete, update 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. 인덱스 때문에 디스크 공간이 더 필요하다.
- filesort 이용
    - 장점
        - 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점으로 변경 정렬해야할 레코드가 많지 않으므로 메모리에서 filesort가 충분히 빠르다.
    - 단점
        - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많을수록 쿼리의 응답속도가 느리다.
- 소트버퍼
    - 정렬을 수행하기 위해서 별도의 메모리공간을 할당받아 사용하는대, 이 메모리 공간을 소트버퍼라고한다.
    - 정렬이 필요한 경우에만 사용되며, 버퍼의 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.
- 정렬의 처리 방식
    - 인덱스
        - ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY 순서대로 생성된 인덱스가 있어야한다. where 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야한다.
        - ORDER BY절을 넣지 않아도 자동으로 정렬된다고 해서 ORDER BY 절 자체를 빼버리고 쿼리를 작성하는 방식은 좋지않다. 또한 ORDER BY절을 빼버리면 어플리케이션 버그로 연결될 수 있다. ORDER BY을 명시해놓으면 성능상의 손해가 없음은 물로인고, 예외사항에서 버그로 연결되지 않는다.
    - 드라이빙 테이블만 정렬(조인이 없는경우 포함) Using filesort
        - 조인을 실행하기 전에, 첫 번째 테이블(드라이빙테이블)의 레코드를 정렬한 다음 조인을 하는것이 정렬의 차선책이다. 조인에서 첫 번째 테이블의 컬럼만으로 ORDER BY 절이 작성되어야한다.
    - 조인 결과를 임시 테이블에 저장 후 , 임시 테이블에서 정렬 Using temporary, Using filesort
        - 쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 select 정렬하는 경우라면 임시 테이블이 필요하지 않지만, 2개 이상의 테이블을 조인해서 그 결과를 정렬해야한다면, 임시테이블이 필요할 수 있다. 3가지 방법 중 제일 느린 정렬 방법이다.
    - 성능비교
        - 웹 서비스에서 쿼리는 order by, limit이 거의 필수적으로 사용되는 경향이 있다. 일반적으로 limit은 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야할 작업량을 줄이는 역할을 한다. 그러나 order by나 group by와 같은 작업은 where 조건을 만족하는 레코드를 limit 건수만큼만 가져와서는 처리될 수 없다. 조건을 만족하는 레코드를 모두 가져와 정렬을 수행하거나 그룹핑 작업을 실행해야만 비로소 limit으로 건수 제한을 할 수 있다. where 조건이 아무리 인덱스를 잘 활용하여도 잘못된 order by, group by 때문에 쿼리가 느려지는 경우가 자주 발생한다.
        - 스트리밍 방식
            - 레코드가 검색될 때마다 클라이언트에게 바로 전달하는 방식
            - MySQL서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다. 쿼리가 얼마나 많은 레코드를 조회하느냐는 관심이 없고 빠른 응답시간을 보장해준다.
            - limit와 같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행시간을 상당히 줄여줄 수 있다.
        - 버퍼링 방식
            - order by, group by와 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다. 우선 where 조건에 일치하는 모든 레코드를 다 가져온 후, 정렬하거나 그룹핑해서 차례대로 보내야한다.
            - 쿼리 결과를 모아서 MySQL 서버에서 일괄 가공해야하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야한다. 그래서 limit 같은것이 성능에 도움이 되지 않는다.

### Group by 처리
> Group by 또한 Order by 와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 요소 중 하나. Group by절에는 having 절을 사용할 수 있는대, Group by 결과에 대해 필터링하는 역할을 수행한다.

- 인덱스 스캔을 이용하는 Group by(타이트 인덱스 스캔)
    - Order by의 경우와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그룹핑할 때, Group by 컬럼으로 이미 인덱스가 있으면 그 인덱스를 차례대로 읽으면서 그룹핑 작업을 수행하고 그 결과로 조인을 수행한다. Group by가 인덱스를 사용하여 처리한다하더라도, 임시테이블이 필요할 때가 있다.
- 루스 인덱스 스캔을 이용하는 Group by
    - 인덱스의 레코드를 건너뛰면서 필요한 부분만 가져오는 것을 의미, 
    ```sql
    explain
    select  emp_no
    from salaries
    where from_date = '1985-01-01'
    Group by emp_no;
    ```
    - salaries 인덱스는 emp_no+from_date로 생성되어있다.
    - where 조건은 인덱스 레인지스캔 접근 방식으로 이용할 수 없다.
    - 순서
        1. emp_no+from_date 인덱스를 차례대로 스캔하면서, emp_no의 첫번째 유일한 값 '10001'을 찾아낸다.
        2. emp_no+from_date 인덱스에서 emp_no가 '10001'인 중에서 from_date가 '1985-01-01'인 레코드만 가져온다. => emp_no='10001' and from_date='1985-01-01' 과 비슷하다.
        3. emp_no+from_date 인덱스에서 emp_no의 그 다음 유니크 값을 가져오고 값이 안나올 때까지 반복한다.
    - 분포도가 좋지 않은 인덱스일 수록 더 빠른 결과를 만들어낸다. 
    - 별도의 임시테이블이 필요치 않다.




