---
layout: post
title:  "질문 10가지"
date:   2021-05-20 14:15
categories: spring
tags: [spring, interview]
---

### 나만의 인터뷰 질문

### SpringMVC 와 SpringBoot 차이점이 무엇인가요? 
- 스프링 MVC는 HTTP 요청 및 응답을 단순화하는 SPRING 프레임워크 내의 라이브러리입니다. ServletAPI를 기반으로하며 MVC는 핵심기능인 Model View Controller의 약자로 각 로직들을 분리할 수 있습니다.
- 스프링 부트는 자동구성을 사용하여 웹 어플리케이션을 빌드하는데 필요한 프로세스를 구성할 수 있습니다. 별도의 서버 설치를 필요 없이 내부 임베디드 톰켓을 사용하여 실행할 수 있습니다.
- 차이점은 스프링 MVC를 사용할 때, 컴포넌트 스캔, 디스패처 서블릿, 뷰리졸버, jar를 설정해줘야합니다. 하지만 스프링 부트는 Springmvc. jar를 통해 자동 구성을 해줍니다. 
- 스프링 MVC, Logging, Jackson-databind등 스프링 MVC버전에 호환되는 것들을 선택해야 했지만 스프링 부트에서는 spring-mvc-starter-web 의존성을 추가해주면 필요한 것들을 기본으로 추가해줍니다.
- 스프링 부트와 MVC를 프로젝트로 각각 진행했을 때, MVC에서 설정이 오래걸렸던 부분들을 스프링 부트로 사용함으로써 단순해졌고, 버전에 대해 고려해야할 점을 없애 빠르게 설정을 해줘서 좋았습니다.

### Immutable이 무엇인가요?
- 객체지향에 프로그래밍에 있어 불변은 생성 후 그 객체를 변경할 수 없는 것입니다.
- 불변이 중요한 이유는 외부에서 객체를 변경할 경우 상태 변화를 추적하기 힘들기 때문에 상태변화에 따른 것을 막는것이 중요합니다.
- 자바에서는 Immutable 객체를 final로 선언하여 사용합니다.
- 정적 팩토리 메서드를 추가하여 외부에서 생성자를 자유롭게 호출되는 것을 방어할 수 있습니다.
- 이렇게 함으로써 다른 사람이 호출하더라도 값이 값이 변하지 않는다는 것을 확신할 수 있습니다.


### 자바 제네릭이 무엇인가요?
- 제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법입니다.
- 자바에서 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입체크를 해주고, 중복 되는 코드를 제거해줄 수 있습니다.
- 제네릭을 사용하면서 사용 가능한 타입을 검증하고 사용 가능하지 않은 타입은 프로그램이 실행되기 전 컴파일 시점에 오류가 발생해 개발자에게 편리한 기능이라고 생각합니다.

### 인터페이스란 무엇인가요?
- 클래스들이 구현해야 하는 동작을 지정하는데 사용하는 추상 자료형입니다.
- 인터페이스를 사용할 때 상속을 해야합니다.
- 인터페이스를 사용함으로써, 확장성이 좋은 코드를 작성할 수 있고, 결합도가 강하지 않은 프로그래밍을 할 수 있습니다.

### Singleton이 무엇인가요?
- 객체의 인스턴스가 오직 하나 1개만 생성하는 것입니다.
- 인스턴스를 오직 하나만 존재한다면, 메모리 측면에서 낭비를 줄일 수 있고, 전역으로 사용되는 인스턴스이기 때문에 데이터 공유가 쉽습니다.
- 요청이 많은 곳에서 사용하면 한 개의 인스턴스만 공유되기 때문에 효율성이 좋습니다
- 하지만 싱글톤 객체 사용유무와 상관없이 클래스 로딩되는 시점에 항상 싱글톤 객체가 생성되고, 메모리를 잡고 있기 때문에 비효율적일 수도 있습니다.


```java
public class Singleton {
    private  static Singleton instance = new Singleton();
    private Singleton(){}

    public static Singleton getInstance() {
        if (istance == null) {
            instance = new Singleton();
        }
        return instance;
    }

}

```

### Spring Security 동작원리를 설명해주세요
- 먼저 스프링 시큐리티는 스프링기반의 어플리케이션 보안을 담당하는 스프링 하위 프레임워크입니다.
- 인증과 권한에 대한 부분을 필터 흐름에 따라 처리하고 있습니다.
- 로그인 요청이 오면 AuthenticationFilter가 HttpServletRequest의 아이디와 비밀번호를 가로챕니다.
- AuthenticationManager에게 UserPasswordAuthenticationToken을 위임합니다.
- 실제 인증을 할 AuthenticationProvider에게 Authentication(UserPasswordAuthenticationToken) 객체를 다시 전달합니다.
- DB에서 사용자 인증 정보를 가져올 UserDetailsService 객체에게 사용자 아이디와 암호화 된 비밀번호를 넘겨주고, UserDetails 객체를 전달받습니다.
- AuthenticationProvider는 UserDetails 객체를 전달 받은 후 사용자 입력정보와 UserDetails를 가지고 인증을 시도합니다.
- 인증이 완료되면 SecurityContextHolder에 담은 후 AuthenticationSuccessHandle을 실행합니다.
- 시큐리티를 쓰면서 요청별 시큐리티에 대한 정보를 가질 수 있어 DB에 저장하는 것보다 더 편리하다고 생각이 들었습니다.


### 다형성이란 무엇인가요?
- 하나의 타입에 여러 객체를 대입할 수 있는 것입니다.
- 다형성을 활용하면 기능을 확장하거나, 객체를 변경해야할 때 타입 변경없이 객체 주입으로 수정을 할 수 있습니다. 상속을 같이 활용한다면 중복되는 코드를 제거할 수 있으므로 객체지향 설계와 가까워 질 수 있다고 생각합니다.
- 다형성 중 오버라이딩을 사용할 경우에 if-else 분기가 늘어나는 것을 제거 할 수 있고, 코드를 수정하는것이 아닌 추가하는 것으로 기존 코드를 건드리지 않을 수 있습니다.
- 다형성을 잘 활용한다면 코드의 중복을 줄이면서, 변경과 확장에 유연한 객체지향 코드를 작성하는데 유용합니다.


### REST API가 무엇인가요?
- 자원을 이름으로 구분하고 정보를 주고받는 것 입니다.
- 현재는 다양한 클라이언트가 등장하기 때문에 JSON을 통해 데이터를 주고 받는다면 어떤 클라이언트가 와도 대응할 수 있습니다.
- 장점은 rest api를 읽는 것만으로도 무엇을 하는지 알 수 있으며, STATELESS 이기 때문에 각자의 역할이 분리되어 있습니다.
- 단점은 표준이 잘 정해져있지 않아 다양한 개발자들이 사용할 때 컨벤션이 지켜지기 어려울 수 있습니다.

### DI / IOC가 무엇인가요?
- DI란 객체간의 의존성을 자신이 아닌 외부에서 주입해주는 것입니다.
- DI는 인터페이스를 통해 다이나믹하게 객체를 주입을 하여 유연한 프로그래밍을 가능하게 하는 패턴으로 좀 더 구첵적인 의미
- IoC란 개발자가 객체를 직접 생성해주는 것이 아닌 스프링 컨테이너가 대신 생성해주는 것입니다.
- IoC는 객체의 흐름, 생명주기관리등 독립적인 제 3자에게 역할과 책임을 위임하는 방식에 프로그래밍 모델입니다. 디자인패턴에서도 찾아볼수 있고 다른 컨테이너를 가진 프레임워크들에서도 찾아볼 수 있습니다
- DI / IoC를 사용하는 이유는 한 클래스를 수정 했을 때, 다른 클래스를 수정해야하는 경우가 발생하는대, DI를 사용함으로써 객체간의 낮은 결합력과 높은 응집도를 유지해줍니다.
- 스프링 프레임워크에서 DI를 사용함으로써 기존 코드를 수정할 때, 인터페이스를 상속한 클래스를 만들어 기존 코드를 건드리지 않고, 확장하며 코드를 작성할 수 있었습니다.


### mybatis의 역할이 무엇인가요?
- 마이바티스는 프록그램 소스코드에서 SQL문장을 별도로 관리하여 XML로 저장하여 JDBC 코드의 작성의 불편함을 없애줍니다.
- JSP와 서블릿 기반으로 프로젝트를 진행했었는대, JDBC 코드의 양이 너무많고 커넥션 관리를 메서드마다 해주는 불편함이 있었는대, 마이 바티스를 사용함으로써 쿼리 그대로 작성하며 유지보수하기와 한 눈에 보기 좋았습니다.


### HTTP 통신
- Transport layer
    - 신뢰성(데이터를 순차적, 안정적인 전달)
    - 전송(포트 번호에 해당하는 프로세스에 데이터 전달)
    - TCP
        - 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜
        - Connection 연결(양방향 통신) 3 way handshake
            - 연결 신청(Syn 비트를 1로 설정해 패킷송신)
            - Syn, Ack 비트를 1로 설정해 패킷송신
            - Ack 비트를 1로 설정해 패킷 송신
            - 연결이 됨
            - 패킷 보냄
            - ack 응답
            - ack를 수신하지 못하면 재전송
        - 혼잡 제어
        - 오류 감지
        - TCP Header
        - 문제점
            - 신뢰성 보장하지만 매번 Connection을 연결하여 시간 손실 발생
            - 패킷을 조금만 손실해도 재전송
    - UDP
        - TCP 보다 신뢰성이 떨어지지만 전송 속도가 일반적으로 빠른 프로토콜
        - Connectionless
        - 에러검출
        - 비교적 데이터의 신뢰성이 중요하지 않을때 사용(영상 스트리밍)
        
### JVM
    - 자바 바이트코드는 타켓 플램폼에 상관없이 JVM 위에서 동작
    - Write Once, Run Anywhere
    - 내부 구조
        - runtime data areas
            - method area, heap -> 스레드 공유
            - 클래스로더가 클래스 파일을 읽어오면 클래스 정보를 파싱해서 method area에 저장
            - 프로그램을 실행하면서 생성된 모든 객체를 heap에 저장
            - java stacks, pc registers, native method stack
                - pc registers
                    - 각 스레드는 메서드를 실행하고 있고, pc는 그 메서드 안에서 바이트드 몇번 째 줄을 실행하고 있는지 알려줌
                - stack
                    - 자바 스택은 스레드별로 1개만 존재하고, 스택 프레임은 호출 될때마다 생성된다. 메서드 실행이 끝나면 스택 프래임은 pop되어 제거된다.
                - stack frame
                    - 자바 bytecode가 아닌 다른 언어들로 작성된 메서드
            - device마다 register 기반으로 만들지 않아 stack을 써서 jvm 운영

### Process vs Thread
    - 실행 단위 : cpu core에서 실행하는 하나의 단위로 프로세스와 스레드를 포괄하는 개념
    - 프로세스 : 하나의 스레드만 가지고 있는 단일 스레드 프로세스
    - 동시성 : 한 순간에 여러가지 일이 아니라, 짧은 전환으로 여러가지 일을 동시에 처리하는 것처럼 보이는 것
    - 프로세스
        - Code : 실행 명력을 포함하는 코드들(스레드에서 공유)
        - Data : Static 변수 혹은 글로벌 변수(공유)
        - Heap : 동적 메모리 영역(공유)
        - Stack: 지역변수, 매개변수, 반환 값 등등 일시적인 데이터
        - PCB
            - Pointer : 대기상태 큐를 구현하기 위한 포인터
            - Process state : 현재 프로세스 상태
            - PID : 고유번호
            - PC : 다음 명령어를 가르키는
        - 컨택스트 스위칭 
            - 모든 자원을 CPU적재 후 다시 모든 자원을 빼고 다른 프로세스의 모든 자원을 적재 후 반복..
        - 멀티 프로세스
            - 각 프로세스 독립적
            - IPC를 사용한 통신
            - 자원 소모적, 개별 메모리 차지
            - 컨텍스트 스위칭 비용이 큼
            - 동기화 작업이 필요하지 않음
    - 스레드
        - 한 프로세스 내에서 구분되어진 실행단위
        - 컨테스트 스위칭
            - 필요한 자원들은 공유하여 다른 스레드가 들어왔을 때 공유
        - 멀티 스레드
            - 공유된 자원으로 통신 비용절감
            - 공유된 자원으로 메모리가 효율적
            - 컨텍스트 스위칭 비용이 적음
            - 공유자원을 관리해줘야함
    - 멀티 프로세스를 이용하는 이유
        - 각 공유된 자원에 문제가 생기면 다른 자원에도 영향이 간다.
        - 멀티 프로세스는 독립적으로 실행하기 때문에 영향을 미치지 않는다.

### blocking vs non-blocking
    - blocking: 자신의 작업을 진행하다가 다른 주체의 작업이 시작이 시작되면 끝날때 까지 기다렸다가 자신의 작업을 시작
    - non-blocking: 다른 주체와 상관없이 자신의 작업을 진행
    - 다른 주체가 작업을 할 때 자신의 제어권이 있는지 없는지로 볼 수 있다.
    - Sync vs Async
        - Sync : 작업을 동시에 수행하거나 동시에 끝나거나, 끝나는 동시에 시작함을 의미
        - Async : 시작 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미
        - 순서와 결과의 관점

### garbage collector
    - 동적으로 할당 된 메모리 영역 중 사용하지 않는 영역을 탐지하여 해제하는 기능
    - stack: 정적으로 할당된 메모리 영역
        - 원시 타입의 데이터가 값과 함께 할당, Heap영역에 생성된 Object 타입의 데이터의 참조 값 할당
    - heap: 동적으로 할당된 메모리 영역
        - 모든 Object type의 데이터가 할당, Heap 영역의 Object를 가르키는 참조 변수가 Stack에 할당
    - 과정
        - 스택의 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
        - reachable object가 참조하고 있는 객체도 찾아서 마킹(mark)
        - 마킹되지 않응 객체를 heap에서 제거(sweep)
    - 언제일어나는지 ?
        - New Genration
            1. Eden
                - 새로운 객체가 할당(반복)
                - 가득 차면 GC 발생 (mark and sweep)
                - unreacahble object가 메모리에서 해제
            2. survival 0
                - eden에서 살아남은 객체가 이동
                - survival1에서 0로 이동
                - 가득 차면 mark and sweep
                - age 값이 특정 값 이상이 되면 Old generation 영역으로 옮겨진다. (promotion)
                - 반복
            3. survival 1
                - survival0에서 1로 이동
                - 이동한 객체는 age값 증가
                - 가득 차면 mark and sweep
                - age 값이 특정 값 이상이 되면 Old generation 영역으로 옮겨진다. (promotion)
                - 반복
            - 0, 1 영역은 둘 중 하나는 항상 비워있는 상태
        - OldGeneration
            - promotion 과정이 일어나면 GC 발생(Major)
            - 반복
    - Garbage Collector 종류
        - Serial GC
            - GC를 처리하는 스레드가 1개
            - CPU 코어가 한개일때만 사용
            - Mark-Compact collection 알고리즘
                - Mark and sweep and compact
                - 메모리가 해제되고 나면 빈 곳이 발생하는데 그것들을 압축
        - Parallel GC
            - GC를 처리하는 스레드가 여러개
            - 메모리가 충분하고 코어의 개수가 많을 때 사용하면 좋다.
        - Concurrent Mark Sweep GC
            - STOP The World
                - GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
                - GC를 실행하는 스레드를 제외한 나머지 스레드 작업을 모두 멈춤
            

### RestFul API
    - 자원의 이름을 구분하여 해당 자원의 상태를 주고 받는 것
    - HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 활용할 수 있는 아키텍처 스타일
    - HTTP URI를 통해 Resource를 명시하고, HTTP Method를 통해 자원의 CRUD 기능을 적용하는 것
    - 장점
        - HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능
        - 메시지를 의도하는 바를 명확하게 나타내므로 가독성이 좋다.
        - 서버와 클라이언트의 역할을 명확하게 분리
    - 단점 
        - 표준이 존재하지 않는다.
    - 특징
        - 서버 , 클라이언트 구조
            - 자원이 있는 쪽이 서버, 자원을 요청하는 쪽이 클라이언트
            - 서로 간 의존성을 줄여준다
        - 무상태
            - Http Protocal은 무상태이므로 RestAPi도 무상태를 갖는다.
            - Client의 Context를 서버에 저장하지 않는다.
            - 서버는 각각의 요청을 완전히 별개로 인식
