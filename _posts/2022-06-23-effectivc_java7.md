---
layout: post
title:  "Effectivce Java - 7"
date:   2022-06-23 16:20:21 +0900
categories: java
---

> #2 기본에 충실하자 

# 일반적인 프로그래밍 원칙

## item49) 지역변수의 범위를 최소하하라
- 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.
- 거의 모든 지역변수는 선언과 동시에 초기화해야한다.
- 지역변수 범위를 최소하하는 마지막 방법은 메서드를 작게 유지하고 한 가지 가닝으 집중하는 것이다.


## item50) 전통적인 for 보다는 for-each문을 사용하라
- for-each를 쓸 수 없는 세가지
    - 파괴적인 필터링
        - 컬렉션을 순회하면서 선택된 원소를 제거해야한다면 반복자의 remove를 호출해야한다.
        - 자바8부터는 Collcetions의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는일을 피할 수 있다.
    - 변형
        - 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야한다면 리스트의 반복자나 배열의 인덱스를 사용해야한다.
    - 병렬 반복
        - 여러 컬렉션을 병렬로 순회해야 한다면 각자 의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야한다.
- 전통적인 for 문과 비교했을 때, 명료하고, 유연하고, 버그를 예방해준다. 성능저하도 없다.


## item51) 라이브러리를 익히고 사용하라
- 무작위 정수하나를 생성하고 싶다고 해보자.

```java
// 흔하지만 문제가 심각한 코드
static Random rnd = new Random();

static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}
```
- 문제
    1. n이 그리 크지 않은 2의 젭곱수라면 얼마지나지않아 같은 수열이 반복
    2. 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주반환한다.
- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
- 자바 7부턴 Random을 사용하지 않고, ThreadLocalRandom으로 대체하면 잘 작동한다.
- 두번째 이점은 핵심적인 일과 크게 관련없는 문제를 해결하느라 시간을 낭비하지 않아도된다.
- 세번쨰 이점은 따로 노력하지 않아도 성능이 지속적으로 개선이된다.
- 네번째 이점은 기능이 점점많아진다. 라이브러리에 부족한 부분이 있다면 개발자 커뉴니티에서 이야기가 나오고 다음 릴리즈에 해당 기능이 추가될 수 있다.
- 자바 개발자라면 util, lang, io 에 익숙해져야한다.

## item60) 정확한 답이 필요하다면 float와 double은 피하라
- float과 double은 공학 계산용으로 설계되었다.
    - 이진 부동소수점 연산으로 쓰이며, `근사치`로 계산하도록 설계
- `특히 금융 관련 계산과는 맞지 않는다.`
- System.out.print(1.03 - 0.42);
    - 0.6100000000001
- 코딩시의 불편함이나 성능저하를 신경쓰지 않는다면 BigDecimal을 사용하라
- 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 크지 않다면 int, long을 사용하라.
- 여덟자리 십진수를 long, 넘어간다면 BigDecimal을 사용해야한다.

## item61) 박싱된 기본타입 보다는 기본타입을 사용하라
- int, double, boolean에 대응하는 박싱된 기본타입은 Integer, Double, Boolean 이다.
- 기본타입과 박싱된 기본타입의 주된 차이 3가지
    1. 기본타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별셩이란 속성을 갖는다.
    2. 기본 타입은 언제나 유요하나, 박싱된 기본타입은 유효하지 않은 값, 즉 NULL을 가질 수 있다.
    3. 메모리 사용면에서 더 효율적이다.

```java

        Comparator<Integer> naturealOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);


        Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j) ? 0 : 1;
        int compare = naturalOrder.compare(new Integer(42), new Integer(42));
        System.out.println(compare); // 결과는 0이어하지만, 1이 나온다. ?

```

- 위 방식이 잘못된 이유는 i 와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본타입값으로 변환한다.
- 두번째 검사에서 i == j 는 두 객체 참조 식별성을 검사한다. i와 j가 서로 다른 Integer의 인스턴스라면 같지 않게 된다.
- 박싱된 기본타입에 연산자 == 를 사용하면 오류가 일어난다.
- 밑의 방식으로 해결하자

```java
    Comparator<Integer> naturealOrder = (iBox, jBokx) -> {
        int i = iBox;
        int j = jBox;
        return (i < j) ? -1 : (i == j) ? 0 : 1;
    }
```

- 오토박싱이 박싱된 기본타입을 사용할 때 번거러움을 줄여주지만, 위험까지는 없애주지 않는다.
- 언박싱 과정에서 NPE를 발생시킬 수 있다.