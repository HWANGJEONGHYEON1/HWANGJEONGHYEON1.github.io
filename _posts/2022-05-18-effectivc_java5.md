---
layout: post
title:  "Effectivce Java - 5"
date:   2022-02-04 16:20:21 +0900
categories: java
---

> #2 기본에 충실하자 - 4

# 열거타입과 애노테이션

### item39) 명명패턴보다 어노테이션으로 사용하라
- 명명패턴 단점
    1. 오타가나면 안된다.
        - junit3에서는 실수로 이름을 잘못지으면 메서드를 그냥 지나간다.(테스트 실패 성공여부 모름)
    2. 올바른 프로그램 요소에만 사용되리라 보증할 방법이 없다.
    3. 프로그램 요소르르 매개변수로 전달할 마땅한 방법이 없다.
- 애노태이션
    - 위의 모든 문제를 모두 해결해주며, Junit4부터 전면 도입되었다.
    - 
```java
/**
테스트 메서드임을 선언하는 메서드
매개변수 없는 정적 메서드 전용
*/

// @Test가 런타임에도 유지되어야한다는 뜻
@Retention(RetentionPolicy.RUNTIME)
// @Test가 반드시 메서드 선언에만 사용돼어야함. 즉, 클래스 변수에는 선언할 수 없다.
@Target(Element.METHOD)
public @interface Test {

}
```

```java
// 명시한 예외를 던져야만 성공하는 테스트 메서드용 애노테이션
@Retention(RetentionPolicy.RUNTIME)
// @Test가 반드시 메서드 선언에만 사용돼어야함. 즉, 클래스 변수에는 선언할 수 없다.
@Target(Element.METHOD)
public @interface ExceptionTest {
    Class<? extends Throwable> value(); // Throwable을 확장한 클래스 객레이며, 모든 예외 타입을 다 수용
}

```


## item40)  @Override 어노테이션을 일관되게 사용하라
- 상위 클래스의 메서드를 재정의하려는 모든 매서드에서 @Override 애노테이션을 달자
- 어노테이션을 달고 컴파일을 하면 컴파일오류로 미리 알 수 있다.
- 구체 클래스에서 상위 클래스의 추상 메서드를 재정의한 경우엔 달지 않아도 된다.

## item41) 정의하려는 타입이라면 마커인터페이스를 사용하라
- 마커 인터페이스는 이를 구현한 클래스의 인스턴스를 구분하는 타입으로 쓸 수 있으나, 마커 애노테이션은 그렇지 않다.
- 마커 인터페이스가 나은점은 적용 대상을 더 정밀하게 지정할 수 있다.