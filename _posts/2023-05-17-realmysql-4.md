---
layout: post
title:  "RealMySQL - 4"
date:   2023-05-13 23:20:21 +0900
categories: db, mysql
---

> RealMySQL

# 실행계획
> MySQL에서는 Explain이라는 명령으로 쿼리의 실행계획을 확인할 수 있는데, 여기에는 많은 정보가 출력된다. DBMS에서는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다 => 옵티마이저

### 쿼리 실행 절차
- 사용자로부터 요청된 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
- SQL의 파싱 정보(파스트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
- 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
- 첫번째 단계
    - `SQL 파싱`, SQL 파서라는 모듈로 처리를 하고 쿼리가 잘못되었다면 이 단계에서 걸러진다.
- 두번째 단계
    - `최적화 및 실행 계획 수립`, 옵티마이저에서 처리
    - 불필요한 조건의 제거 및 복잡한 연산 단순화
    - 여러 테이블의 조인이 있는경우 어떤 순서로 테이블을 읽을지 결정
    - 각 테이블에 사용된 조건과 인덱스 통계정보를 이용해 사용할 인덱스 결정
    - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야하는지 결정
- 세번째 단계
    - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, MySQL 엔진에서는 스토리지 엔지으로부터 받은 레코드를 조인하고 정렬하는 작업을 수행한다.

### 옵티마이저의 종류
- 디비 서버에서 두뇌 역할
- 비용기반 최적화
    - 쿼리르 처리하기 위한 여러가지 가능한 방법을 만들고, 각 작업 단위의 비용정보와 대상 테이블의 예측된 통계정보를 이용해 각 실행 계획별 비용을 산출한다. 산출된 각 실행 방법별로 최소 비용이 소요되는 처리 방식을 선택해 최종 쿼리를 실행한다.
- 규칙 기반 최적화
    - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다. 같은 쿼리는 항상 실행계획도 비슷하다. 
- 대부분의 RDBMS는 비용 기반 최적화를 사용한다.

### 통계정보
- 비용 기반 최적화에서 가장 중요한 것은 통계정보이다. 통계정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행해버린다.
    - 예를들어, 1억 건의 레코드가 저장된 테이블의 통계정보가 갱신되지 않아, 레코드가 10건 미만인것처럼 되었다면, 옵티마이저는 실제 쿼리 실행 시 인덱스레인지 스캔이 아니라 풀 스캔으로 실행해버릴 수도 있다.
- Mysql에서 관리되는 통계정보는 대략의 레코드 건수와 인덱스의 유니크한 값의 개수 정보가 전부이다.
    - 오라클같은 디비는 통계정보가 상당히 정적이고 수집에 많은 시간이 소요되기때문에 백업하기도 한다.
- Mysql에서는 사용자가 알아채지 못하는 순간순간 자동으로 변경되기 때문에 상당히 동적이다. 하지만 레코드 수가 많지 않다면 통계정보가 상당히 부정확한 경우가 많으므로 `ANALIZE` 명령을 이용해 강제적으로 통계정보를 업데이트해야할 떄가 있다.

### 실행계획분석
- `EXPLAIN` 명령사용
```sql
explain
select e.emp_no, e.first_name
from employee e, salaries s
where e.emp_no = s.emp_no
limit 10;
```

|id|select_type|table|type|key|key_len|ref|rows|extra|
|:---|---:|---:|---:|---:|---:|---:|---:|---:|
|1|simple|e|index|ix_first_name|44||300584|using index|
|1|simple|s|indexref|primary|4|employees.e.emp_no|4||
- 표의 각 레코드는 쿼리 문장에서 사용된 테이블의 개수만큼 출력된다.
- 실행 순서는 위에서 아래로 표시된다. 출력된 실행 계획에서 위쪽에서 출력된 결과일 수록 부분이거나 먼저 접근한 테이블이고 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블에 해당된다.
- 쿼리문장과 비교하면 알기 쉽다.
- id 컬럼
    - 하나의 SELECT 문장은 다시 1개 이상의 하위 SELECT를 포함할 수 있다.
- select_type 컬럼
    - SELECT 쿼리가 어떤 타입인지 
        - SIMPLE: UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT, 일반적으로 제일 바깥의 쿼리
        - PRIMARY: UNION이나 서브 쿼리가 포함된 쿼리의 실행계획에서 가장 바깥쪽에 있는 단위 쿼리
        - UNION, UNION RESLUT, SUBQUERY, DERIVED ..
- table 컬럼
    - 테이블 기준으로 표시, 별칭이 있다면 별칭으로 나타난다.
- type 컬럼
    - 테이블의 레코드를 어떤 방식으로 읽었는지 의미, 인덱스를 사용하여 레코드를 읽었는지, 테이블을 처음부터 끝까지 읽었는지 등 중요한 정보이다.
    - system, const, eq_ref, ref, fullext, ref_or_null, unique_subquery, index_subquery, range, index_merge, index, ALL
        - ALL을 제외하면 나머지는 인덱스를 접근하는 방법
        - system: tb_dual 같은 곳에서 참조하는 형태
        - const: 레코드의 건수와 상관없이 주키나 유니크 키 컬럼을 이용하는 where 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리방식 (다른 DBMS에서는 유니크 인덱스 스캔이라 부름)
            - 다중 컬럼으로 구성된 유니크 키 중에서 일부컬럼 조건만 사용할 때는 const가 아니라 ref로 나타난다.
            - `조인의 순서에 관계없이 주키나 유니크키가 모든 컬럼에 대해 반드시 동등 조건으로 검색되어야한다.`
        - eq_ref: 여러 테이블이 조인되는 쿼리의 실행계획
            - 조인에서 처음 읽은 테이블읠 컬럼 값을, 그 다음 읽어야할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때를 eq_ref라고한다. 유니크 키로 검색할 때 유니크 인덱스는 NOT_NULL이어야한다.
        - ref: 조인의 순서와 관계없이 사용되며, 주키나 유니크 제약조건도 없다. 인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref를 사용한다.  
            - const, eq_ref, ref는 where 조건 절이 사용되어야한다는 공통점이 있음. =>성능상 좋은 접근
        - fulltext: 전문 검색 인덱스를 사용하여 레코드를 읽는 접근 방법
            - type의 순서가 일반적으로 처리 성능의 순서이긴하지만 실제로 데이터의 분포나 레코드의 건수에 따라 빠른 순서는 달라질 수 있다. 하지만 이놈은 통계정보가 관리되지 않으며, 특별한 키워드를 사용해야한다. MATCH, AGAINST -> 권하지 않는다.
        - ref_or_null: ref 접근 방식과 비슷한대, NULL 비교가 추가된 형태이다. 접근 방식의 이름 그대로 ref 방식 또는 NULL 비교 방식이다. 실무에서는 잘 안나온다.
        - unique_subquery: where 조건절에서 IN 형태의 쿼리를 위한 접근 방식이다. 서브쿼리에서 중복되지 않은 유니크한 값만 반활할 때 이 접근 방법을 사용한다. `select * from ~ where no in (select ~)`
        - index_subquery: in 형태의 조건에서 서브쿼리의 반환 값에 중복된 값이 있을수 있지만 인덱스를 이용해 중복된 값을 제거한다.
        - range: 인덱스 레인지 스캔, 범위로 검색하는 경우인대, 주로 IS NULL, BETEWEEN, IN, LIKE 등으로 인덱스를 검색할 때 사용한다.
        - index: 인덱스를 처음부터 끝까지 읽는 인덱스 풀스캔을 의미. range 와 같이 효율적으로 인덱스의 필요한 부분만 읽는것을 의미하지 않는다. `limit`이 있으면 효율적..
        - ALL: 풀 스캔. 가장 비효율적인 방법
        - possible_keys: 사용될 법했던 인덱스의 목록 -> 무시하자;;
        - key: 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다. 쿼리를 튜닝할 때는 `Key 컬럼에 의도했던 인덱스가 표시되었는지 확인하는것이 중요하다.`
        - key_len: 매우 중요한 정보 중 하나, 실제로 사용하는 테이블은 단일 컬럼으로만 만들어진 인덱스보다 다중컬럼으로 이루어진게 많다. 실행계획의 key_len은 쿼리를 처리하기 위해 다중컬럼으로 구성된 인덱스에서 몇개의 컬럼까지 사용했는지 알려준다. 더 정확하게는 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.
        - rows: 옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나의 실행 계획을 수립한다. 실행계획의 rows 컬럼에 출력되는 실제 값과 실제 쿼리 결과 반환된 레코드 건수는 일치하지 않는 경우가 많다. `쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야하는지를 의미한다.`
        - Extra: 쿼리의 실행계획에서 성능에 관련된 중요한 내용이 적힌다.
             - const row not found
                - const 접근방식으로 테이블을 읽었지만, 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면 나타난다.
            - distinct
                - 쿼리의 Distinct 키워드가 표시될 때
            - Full scan on null key
                - col in (select cloe 2 from ..) 의 조건과 같은 쿼리에서 자주 발생된다.
            - Impossible HAVING, WHERE
                - having e.emp_no is null 
                - 위의 조건의 컬럼 타입이 not null 타입이다 그러므로 having이 필요없다.는 것을 알려준다.
                - WHERE도 항상 조건이 FALSE인 경우 표시된다.
            - Impossible Where noticed after reading const tables
                - `explain select * from emp where emp_no=0`
                - emp_no = 0 인 데이터를 실제로 확인할 수 없다. 그런데 실행계획만 했을 뿐인대 옵티마이저는 사번이 0인 사원이 없다는것까지 확인한다.
                - 실행 계획을 만드는 과정에서 쿼리의 일부분을 실행해 본다는 사실을 알 수 있다.
            - No matching min/max row
                - min/max() 함수로 실행되는 컬럼의 결과가 없을 때 나온다.
            - Not Exist
                - a 테이블에는 존재하지만, b 테이블에는 존재하지 않는 쿼리가 자주 사용되는 것은 주로 NOT IN, NOT EXISTS를 사용한다.
                - 이 쿼리는 주로 아우터가 더 성능을 좋게 한다.
            - Range checked for each record
                - e1.emp_no, e2.emp_no를 읽을 때 인덱스레인지 스캔과 풀스캔 중 어느 것이 효율적인지 판단할 수 없게된다.
                - 매 레코드마다 인덱스 레인지 스캔을 체크한다.
            - unique row not found
                - 두 개의 테이블이 각각 유니크 컬럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하지 레코드가 존재하지 않을 때
            - ...
