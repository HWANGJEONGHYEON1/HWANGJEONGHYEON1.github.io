---
layout: post
title:  "RealMySQL - 3"
date:   2023-05-13 23:20:21 +0900
categories: db, mysql
---

> RealMySQL

# 인덱스
> 데이터 베이스의 성능을 언급하면 뺄 수 없는 부분

### 인덱스란?
- 책의 내용을 데이터라고 보면, 책의 내용을 `찾아보기`가 인덱스가 된다.
- 모든 데이터 중 특정 데이터를 가져올 때는 찾기가 어렵지만 `정렬`이 되어 있다면 빠른속도로 찾을 수 있다.
- 자료구조 중 SortedList, ArrayList가 있다.
    - SortedList 
        - 데이터가 저장될 때마다 항상 값을 정렬해야하므로 저장하는 과정은 느리지만, 조회는 빠르다. 인덱스가 많은 테이블은 당연히 INSERT, UDDATE, DELETE 처리가 느리다.
- 인덱스를 역할별로 구분해 본다면 primary key, secondary key가 있다.
    - primary key: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미, 식별자라고 부른다. NULL을 허용하지 않는것이 특징
    - secondary key: 프라이머리 키와 비슷하고 대체할 수 있다고 한다. 
- 데이터 저장 방식 알고리즘
    - B-Tree: 칼럼의 값을 변형하지 않고, 원래의 값을 이용하여 인덱싱하는 알고리즘
    - Hash 인덱스 알고리즘: 컬럼의 값으로 값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색지원, 하지만 값을 변형하여 인덱싱하기 때문에, 전방 일치와 같이 일부만 검색하고 할 때 사용할 수 없음.
    - Factal-Tree: B-tree의 단점을 고안된 알고리즘, 값을 변경하지 않고 인덱싱하여 범용적인 목적으로 사용할 수 있다는 측면세어 B-Tree와 비슷하지만, 데이터가 저장 삭제 될 때 비용을 상당히 줄 일수 있다.

### B-Tree index
- 이진트리가 아니라 `Balanced`의 약자다.
- 인덱스 구조체 내에서는 항상 정렬된 상태로 유지.
- 전문 검삭과 같은 특수한 요건이 아닌경우 거의 사용한다.
- 구조 및 특징
    - 최상위 노드 `루트 노드`
    - 가장 하위를 `리프 노드`
    - 중간 노드를 `브랜치 노드`
    - 데이터베이스에서는 인덱스와 실제 데이터가 따로 관리된다. 리프노드는 항상 실제 데이터의 레코드를 찾아가기 위한 주소 값을 가지고 있다.
    - 인덱스는 테아블의 키 컬럼만 가지고 있으므로, 나머지 컬럼을 찾으려면 데이터 파일에서 해당 레코드를 찾아야한다.
- 인덱스 사용에 영향을 미치는 요소
    - 인덱스를 구성하는 컬럼의 크기와 레코드의 건수, 유니크한 인덱스 키값의 개수 등에 성능이 영향을 받는다.
    - InnoDB의 모든 페이지 크기는 16KB로 고정돼 있다.
        - 하나의 인덱스 페이지에 몇 개의 키를 저장할 수 있을까? 16 * 1024 / (16+12(평균적으로 이정도 라고 생각하고 계산)) = 585개
        - 인덱스 키 값이 커지면 16 * 1024 / (16 + 32) = 372개
        - SELECT 쿼리가 500개 읽어야한다면, 전자의 경우는 한번에 읽을 수 있지만, 후자의경우는 2번 읽어야한다.
        - 디스크로부터 읽어야할 횟수가 늘어나고, 그만큼 느려진다. 
- 데이터 읽기
    - 인덱스 레인지 스캔
        - 인덱스를 통해 레코드를 한건만 읽는 경우와 한건 이상을 읽는 경우를 각각 다른이름으로 구분하지만, 모두 묶어서 `인덱스 레인지 스캔`이라고 한다.
        ```sql
        select * from employees
        where first_name between 'ebbe' and 'gad';
        ```
        - 인덱스의 범위가 결정되었을 때 사용하는 방식
        - 루트 노드부터 비교를 시작하여 브랜치 노드를 거치고 최종적으로 리프노드까지 찾아야 실제로 원하는 시작지점을 찾을 수 있다.
        - 풀스캔
            - 인덱스의 처음부터 끝까지 모두 읽는 방식
            - 인덱스의 첫번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
                - 예를들어 인덱스는 A,B,C 순서대로 만들어졌지만, B나 C 로 검색하는 경우이다.
    - 인덱스 정렬 및 스캔 방향
        - 어느 방향으로 읽을 지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.
        - 인덱스를 생성 시섬에 인덱스를 구성하는 각 컬럼의 정렬을 오름차순 또는 내림차순을 설정할 수 있다.
            - MySQL 은 인덱스를 혼합하여 생성하는 기능을 지원하지 않는다.
            ```sql
            create index ix_teamname on employees (team_name asc, user_name desc);
            ```
            - 모든 키워드가 무시되고 오름차순으로만 정렬된다. => 문법상으로만 정렬된다.
        ```sql
        select * from employees order by first_name desc limit 1;
        -- 인덱스를 처음부터 끝까지 오름차순으로 읽어 마지막 레코드를 하나만 가져올 것인가?
        ```
        - 인덱스는 항상 오름차순으로 정렬되어있지만, 인덱스를 최소값부터 읽으면 오름차순으로 값을 가져올 수 있고, 최대값부터 거꾸로 읽으면 내림차순으로 가져올 수 있다. 그래서 쿼리는 인덱스를 역순으로 접근해 첫번째 레코드만 읽으면 된다.
    - 인덱스의 가용성
        - B-Tree 인덱스의 특징은 왼쪽 값에 기준에서 오른쪽 값이 정렬돼 있다.
        - 왼쪽은 하나의 컬럼내에서 뿐만 아니라 다중 컬럼 익덱스의 컬럼에 대해서도 적용된다.
        - caseA) Index(first_name) -> Like 같은 조건이오면 인덱스의 효과를 얻을 수 없다.
            ```sql select * from employees where like '%aa'```
        - caseB) Index(dept_no, emp_no) -> dept_no에 대해 먼저 정렬 후, emp_no 컬럼 값으로 재정렬
            ```sql select * from employees where emp_no >= 144```


