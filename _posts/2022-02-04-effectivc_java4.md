---
layout: post
title:  "Effectivce Java - 4"
date:   2022-02-04 16:20:21 +0900
categories: java
---

> #2 기본에 충실하자 - 4

# 모든 객체의 공통 메서드

### item20) 추상 클래스보다는 인터페이스를 우선하라
- 둘의 가장 큰 차이점은 추상 클래스를 구현하는 클래스는 반드시 추상클래스의 하위 클래스로 정의된다.
    - 자바는 단일 상속만 지원하기 때문에, 추상 클래스 방식은 새로운 타입을 정의하는데 큰 제약이 된다.
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.

### item21) 인터페이스는 구현하는 쪽을 생각해 설계해라
- 자바8에서 디폴트 메서드가 생겼다.
- 디폴트 메서드가 생겼더라도 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기 어렵다.
- 컴파일에 성공하더라도, 기존 구현체에 런타입 오류를 일으킬 수 있다.

### item22) 인터페이스는 타입을 정의하는 용도로만 사용하라
- 클래스가 어떤 인터페이스를 구현한다는것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것

### item23) 태그 달린 클래스보다는 클래스 계층구조를 활용하라
- 태그 달린 클래스는 장황하고, 오류나기 쉽고, 비효율적이다.
- 계층구조를 어설프게 흉내낸 것
- 타입이 의미 별로 따로 존재하면 변수의 의미를 명시하거나 제한할 수 있고, 특정 의미만 매개변수로 받을 수 있다.

### item24) 멤버 클래스는 되도록 static으로 만들라 
- 멤버클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.
    - static을 생략하면 바깥 인스턴스로의 `숨은 외부 참조`를 갖게된다.
    - 이 참조를 저장하려면 시간과 공간이 소비된다.
        - 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못한다면 메모리 누수가 발생할 수 있다. => 참조가 눈에 보이지 않는다.

### item25) 톱레벨 클래스는 한 파일에 하나만 담으라
- 컴파일러가 한 클래스에 대한 정의를 여러개 만드는 일을 막아준다. 소스파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.


# 제네릭
> 자바 5부터 지원 제네릭을 지원하기전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 했다. 실수로 타타입의 객체를 넣어두면 런타입 시 형변환 오류가 났다. 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 됬고, 컴파일러는 알아서 형변환 코드를 추가할 수 있게되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일시점에 차단하여 안전하고 명확한 프로그램을 만들어준다.


### item26) Raw 타입은 사용하지마라
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 제네릭 클래스 혹인 제네릭 인터페이스라 한다.
- Raw type : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
    - List<E> 로 타입은 List
- Raw type을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게된다.
- List vs List<Object> 차이
    - List<Object>은 모든 타입을 허용한다는 의사를 컴파일러에게 전달한다.
- `Raw 타입을 사용하면 런타임에 예외가 날 수 있으니 사용하면 안된다.`

### item27) 비검사 경고를 제거하라
- 할 수 있는 한 모든 비검사 경고를 제거하라
    - 제거를 한다면 타입의 안정성이 보장된다.
    - 잠재적 가능성을 뜻하니 최선을 다해 제거해야한다.
- 경고를 제거할 수는 없지만 타입의 안정하다고 확신할 수 있다면 @SuppressWarnings("unchecked") 어노테이션을 달아 경고를 숨기자
    - 항상 가능한 좁은 범위에 적용하자


### item28) 배열보다는 리스트를 사용하라
- 배열은 공변이다 
    - `Sub가 Super의 하위 타입이라면 배열 Sub[]은 배열 Super[]의 하위타입이 된다. 함께 변한다.`
- 제네릭은 불공변이다.
- 배열은 런타임에는 타입이 안전하지만, 컴파일에는 그렇지 않다.

### item29) 이왕이면 제네릭 타입으로 만들라.
- 클라이언트에서 직접 형변환을 해야하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
- 새로운 타입을 설계할 때는 형변환없이도 사용할 수 있도록 하라.
- 기존 타입 중 제네릭이 있어야하는게 있다면, 제네렉 타이브로 변경하자. 기존 클라이언트에는 아무 영향을 주지 않으면서 새로운 사용자를 훨씬 편하게 해준다.

### item30) 이왕이면 제네릭 메서드로 만들라.

- 제네릭 타입과 마찬가지로, 클라이언트에서 매개변수와 반환값을 명시적으로 반환해야하는 메서드보다 제네릭 메서드가 더 안전하며 쓰기 쉽다.
- 타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋다.
- 코드

```java
public static Set union(Set s1, Set s2) { 
    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}

public static E Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<E(s1);
    result.addAll(s2);
    return result;
}
```

### item31) 한정적 와일드 카드를 사용해서 API 유연성을 높이자.
- 와일드카드
    - 제네릭코드에서 물음표로 표기되어있는 것을 말한다. 아직 알려지지 않은 타입
- PECS
    - producer - extends, consumer-super
    - 매게변수화 타입 T가 생산자인 경우 `<? extends E>`(타입의 제한을 풀어줄 때 사용), 소비자이면 `<? super E>`를 사용(타입을 제한할 때)

```java
    public static class Stack<E> {
        public void pushAll(Iterable<? extends E> src) { // 한정적 와일드카드 사용 E로만 했을시 에러
            for (E e : src) {
                push(e);
            }
        }

        public void push(E e) {

        }
    }

    @Test
    void test() {
        Stack<Number> stack = new Stack<>();
        Iterable<Integer> integers = new Iterable<Integer>() {
            @Override
            public Iterator<Integer> iterator() {
                return null;
            }
        };
        stack.pushAll(integers); // 

    }
```

- 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매게변수에 와일드카드 타입을 사용하라.

