---
layout: post
title:  "Effectivce Java - 4"
date:   2022-02-04 16:20:21 +0900
categories: java
---

> #2 기본에 충실하자 - 4

# 모든 객체의 공통 메서드

### item20) 추상 클래스보다는 인터페이스를 우선하라
- 둘의 가장 큰 차이점은 추상 클래스를 구현하는 클래스는 반드시 추상클래스의 하위 클래스로 정의된다.
    - 자바는 단일 상속만 지원하기 때문에, 추상 클래스 방식은 새로운 타입을 정의하는데 큰 제약이 된다.
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.

### item21) 인터페이스는 구현하는 쪽을 생각해 설계해라
- 자바8에서 디폴트 메서드가 생겼다.
- 디폴트 메서드가 생겼더라도 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기 어렵다.
- 컴파일에 성공하더라도, 기존 구현체에 런타입 오류를 일으킬 수 있다.

### item22) 인터페이스는 타입을 정의하는 용도로만 사용하라
- 클래스가 어떤 인터페이스를 구현한다는것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것

### item23) 태그 달린 클래스보다는 클래스 계층구조를 활용하라
- 태그 달린 클래스는 장황하고, 오류나기 쉽고, 비효율적이다.
- 계층구조를 어설프게 흉내낸 것
- 타입이 의미 별로 따로 존재하면 변수의 의미를 명시하거나 제한할 수 있고, 특정 의미만 매개변수로 받을 수 있다.

### item24) 멤버 클래스는 되도록 static으로 만들라 
- 멤버클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.
    - static을 생략하면 바깥 인스턴스로의 `숨은 외부 참조`를 갖게된다.
    - 이 참조를 저장하려면 시간과 공간이 소비된다.
        - 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못한다면 메모리 누수가 발생할 수 있다. => 참조가 눈에 보이지 않는다.

### item25) 톱레벨 클래스는 한 파일에 하나만 담으라
- 컴파일러가 한 클래스에 대한 정의를 여러개 만드는 일을 막아준다. 소스파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.


# 제네릭
> 자바 5부터 지원 제네릭을 지원하기전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 했다. 실수로 타타입의 객체를 넣어두면 런타입 시 형변환 오류가 났다. 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 됬고, 컴파일러는 알아서 형변환 코드를 추가할 수 있게되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일시점에 차단하여 안전하고 명확한 프로그램을 만들어준다.


### Raw 타입은 사용하지마라
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 제네릭 클래스 혹인 제네릭 인터페이스라 한다.
- Raw type : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
    - List<E> 로 타입은 List
- Raw type을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게된다.
- List vs List<Object> 차이
    - List<Object>은 모든 타입을 허용한다는 의사를 컴파일러에게 전달한다.
- `Raw 타입을 사용하면 런타임에 예외가 날 수 있으니 사용하면 안된다.`